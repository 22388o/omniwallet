create database Omniwallet;

/* psql command to use the newly created database */
\connect Omniwallet;

/*
 * Notes:
 * 1. Need to define Cascade/Restrict behavior for foreign keys to maintain referential integrity
 * 2. Need to define & flesh out dictionary tables
 * 3. Need to identify tables & indexes for administrative purposes, e.g. analytics
 *
 * All token amounts are stored as 19 digit integers - numeric(19). The PropertyType indicates if the
 * currency (or smart property) is divisible or indivisible.
 */

/* 
 * AddressRole type definitions:
 *	issuer created a smart property
 *	participant is an investor in a crowdsale
 *	payee received a Send to Owners amount
 *	recipient received a Simple Send
 *	sender sent a Simple Send
 */
create type AddressRole as enum ('issuer', 'participant', 'payee', 'recipient', 'sender');
create type Protocol as enum ('Bitcoin', 'Mastercoin');
create type Ecosystem as enum ('Production', 'Test');
create type ObjectType as enum ('address', 'property', 'tx_version_type');
create type TxState as enum ('pending', 'valid', 'not valid');
create type WalletState as enum ('Active', 'Inactive', 'Suspended');

/* Wallets have addresses with private keys. Objects being watched are in the Following table */
create table if not exists Wallets (
	WalletID uuid
	, Created timestamp(0) not null default CURRENT_TIMESTAMP
	, LastLogin timestamp(0) not null default CURRENT_TIMESTAMP
	, LastBackup timestamp(0) null
	, SignedIn boolean not null default FALSE		/* signed in now? */
	, WalletState WalletState not null default 'Active'
	, WalletStateDate timestamp(0) not null default CURRENT_TIMESTAMP
	, WalletBlob text null					/* encrypted w/ wallet password */
	, UserName varchar(32) null				/* (future) encrypted */
	, Email varchar(64) null				/* (future) encrypted */
	, Settings json null					/* (future) user preferences */
	
	, primary key (WalletID)
)
;

/*
 * Balances for each PropertyID (currency) owned by an Address
 * for all addresses we know about, even if they're not in a wallet
 */
create table if not exists AddressBalances (
	Address	varchar(64)				/* Bitcoin addresses are 34 chars */
	, Protocol Protocol not null default 'Bitcoin'	/* initially 'Bitcoin' or 'Mastercoin' */
	, PropertyID smallint not null default 0	/* Bitcoin */		
	, Ecosystem Ecosystem null
	, BalanceAvailable numeric(19) not null default 0
	, BalanceReserved numeric(19) null
	, BalanceResForOffer numeric(19) null		/* may not be used by most addresses */
	, BalanceResForAccept numeric(19) null		/* may not be used by most addresses */
	, LastTxHash varchar(96) null				/* last tx that affected this currency for this address, null if no tx's */

	, primary key (Address, Protocol, PropertyID)
)
;

/* Addresses with private keys owned by each Wallet. See Following table for objects watched by a wallet. */
create table if not exists AddressesInWallets (		/* many-to-many */
	Address varchar(64) not null		/* Address must exist in the AddressBalances table */
	, PropertyID integer not null		/* needed here for foreign key reference */
	, Protocol Protocol not null		/* initially 'Bitcoin' */
	, WalletID uuid	not null		/* WalletID must exist in the Wallets table */

	, primary key (WalletID, Address, Protocol, PropertyID)
	, foreign key (WalletID) references Wallets on delete CASCADE on update CASCADE	/* del/upd rows here if corresponding row is deleted/updated */
	, foreign key (Address, Protocol, PropertyID) references AddressBalances
)
;

/* to find the wallets that have a particular address. */
create index AddressIndex on AddressesInWallets (Address, Protocol, PropertyID)
;

/* block header information, from https://en.bitcoin.it/wiki/Protocol_specification */
create table if not exists Blocks (
	BlockNumber integer not null
	, Protocol Protocol not null		/* initially 'Bitcoin' */
	, BlockTime timestamp(0) not null	/* timestamp recording when this block was created (Will overflow in 2106) */
	, Version integer null		/* Block version information, based upon the software version creating this block */
	, PrevBlock varchar(32) null	/* hash value of the previous block this block references */
	, MerkleRoot varchar(32) null	/* reference to a Merkle tree collection which is a hash of all transactions related to this block */
	, Bits integer null		/* The calculated difficulty target being used for this block */
	, Nonce integer null		/* The nonce used to generate this block… to allow variations of the header and compute different hashes */
	, TxCount integer null		/* Number of transaction entries */

	, primary key (BlockTime, BlockNumber, Protocol)
)
;

/* to find block info by block number */
create index BlockNumTime on Blocks (BlockNumber, Protocol, BlockTime)
;
	
/* all the transactions we know about; keeping them (forever?) even after an address or wallet is de-activated */
create table if not exists Transactions (
	TxHash varchar(96) not null		/* varchar so we can use LIKE & other string matching  */
	, Protocol Protocol not null		/* initially 'Bitcoin' or 'Mastercoin' */
	, TxDBSerialNum serial8 unique		/* db internal identifier for each tx, for faster joins */
	, TxType smallint not null		/* from the msg for a 'Mastercoin' tx */
	, TxVersion smallint not null		/* from the msg for a 'Mastercoin' tx, 1(?) for a Bitcoin tx */
	, Ecosystem Ecosystem null		/* Null for 'Bitcoin'-only tx's */
	, TxSubmitTime timestamp(0) not null	/* when it was sent, use (TxBlocktime - 10 minutes) as estimate */
	, TxState TxState not null		/* pending, valid, not valid */
	, TxErrorCode smallint			/* successful? if not, why not? (see ErrorCodes) */		
	, TxBlockNumber integer null	
	, TxSeqInBlock integer null		/* determined by order of tx's in the block */

	, primary key (TxHash, Protocol)
)
;

/* to find transactions by the db internal id */
create unique index TxDBSerials on Transactions (TxDBSerialNum, TxHash, Protocol)
;

/* to find transactions by type */
create index TxTypes on Transactions (TxType, TxVersion, TxHash, Protocol)
;

/* to find transactions by order in the blockchain */
create index TxSeq on Transactions (TxBlockNumber, TxSeqInBlock, TxHash)
;

/* to find transactions by time */
create index TxTime on Transactions (TxBlockTime, TxSeqInBlock, TxHash)
;

/* for the future if we decide to store the tx JSON representation */
create table if not exists TxJSON (
	TxDBSerialNum int8 unique not null	/* db internal identifier for each tx, for faster joins */
	, TxMsg	json not null			/* the tx message fields */

	, primary key (TxDBSerialNum)
	, foreign key (TxDBSerialNum) references Transactions(TxDBSerialNum)
)
;

/* Addresses that are involved in each transaction, with their role and changes to balances */
create table if not exists AddressesInTxs (					/* many-to-many */
	Address	varchar(64) not null
	, PropertyID integer not null	
	, TxHash varchar(96) not null			/* varchar so we can use LIKE & other string matching  */
	, Protocol Protocol not null			/* initially 'Bitcoin' or 'Mastercoin' */
	, TxDBSerialNum int8 not null default -1	/* db internal identifier for each tx, for faster joins */
	, AddressTxIndex int2 not null			/* position in the input or output list */
	, AddressRole AddressRole not null		
	, BalanceAvailableCreditDebit numeric(19) null		/* how much the balance changed, */
	, BalanceReservedCreditDebit numeric(19) null		/* how much the balance changed, */
	, BalanceResForOfferCreditDebit numeric(19) null	/* null means the balance type wasn’t involved in the tx */
	, BalanceResForAcceptCreditDebit numeric(19) null	/* as opposed to 0 meaning no change in the balance as a result of the tx */
	
	, primary key (Address, TxDBSerialNum, PropertyID, AddressRole)
	, foreign key (Address, Protocol, PropertyID) references AddressBalances
	, foreign key (TxDBSerialNum, TxHash, Protocol) references Transactions (TxDBSerialNum, TxHash, Protocol)
)
;

/* to find info about addresses affected by a particular transaction */
create index TxDBSerial on AddressesinTxs (TxDBSerialNum, PropertyID)
;

/* to find info about addresses affected by a particular transaction */
create index TxHash on AddressesinTxs (TxHash, Protocol, PropertyID)
;

/* actions on Smart Properties (and currencies??); 1 row for each action on the SP */
create table if not exists PropertyHistory (
	Protocol Protocol			/* Protocol plus PropertyID uniquely identify a property */
	, PropertyID integer			/* signed 32-bit */
	, Issuer varchar(64) not null		/* Address that created it */
	, Ecosystem Ecosystem not null		/* Production or Test (for now) */
	, TxHash varchar(96) not null		/*the tx that performed the action */
	, TxDBSerialNum int8 unique not null	/* db internal identifier for each tx, for faster joins */
	, TxBlockTime timestamp(0) null		/* to identify the  action on a particular property */
	, PropertyName varchar(256) null
	, PropertyType smallint null		
	, PrevPropertyID integer null default 0
	, PropertyURL varchar(256) null
	, NumberOfTokens numeric(19) null	/* for a tx50 */
	, PropertyData varchar(256) null
	, CrowdsaleDeadline timestamp(0) null
	, PropertyCategory varchar(256) null		/* see PropertyCategories - TBD */
	, PropertySubcategory varchar(256) null		/* see PropertyCategories - TBD */

	, primary key (PropertyID, Protocol, PropertyName)
	, foreign key (Issuer, Protocol, PropertyID) references AddressBalances (Address, Protocol, PropertyID)
	, foreign key (TxHash, Protocol) references Transactions
	, foreign key (TxDBSerialNum, TxHash, Protocol) references Transactions (TxDBSerialNum, TxHash, Protocol)
)
;

/* to find Smart Property history by issuing address */
create index PropHist_Issuer on PropertyHistory (Issuer, PropertyID, Protocol, PropertyName, TxBlockTime)
;

/* A wallet can watch any object - address, SP, tx type (even a blocknumber?) */
create table if not exists Following (			
	 WalletID uuid			
	, ObjectType ObjectType
	, ObjectID varchar(64)	/* works with Addresses initially */
				/* future - Event, see EventTypes (to generate alerts/notifications) */
	, primary key (WalletID)
	, foreign key (WalletID) references Wallets
)
;

/* directional exchange rates between pairs of properties; can work with fiat currencies as well */
/* rate for 1 --> 2 not necessarily the same as the reciprocal of rate for 2 --> 1 */
create table if not exists ExchangeRates (			
	Protocol1 Protocol		/* see Protocols */
	, PropertyID1 integer		/* need exchange rates for fiat currencies */
	, Protocol2 Protocol
	, PropertyID2 integer			
	, Rate1For2 float		/* (1 for 2) */		
	, AsOf timestamp(0)
	, Source varchar(256)		/* URL */

	, primary key (PropertyID1, Protocol1, PropertyID2, Protocol2) 
)
;

/* dictionary of known protocols */
create table if not exists Protocols (
	Protocol Protocol unique not null
	, BaseProtocol Protocol not null	/* e.g. Bitcoin is the base of Mastercoin, Protocol = BaseProtocol if a base protocol */
	, URL varchar(256) null
)
;

/* Load the initial known protocols */
insert into Protocols values (
	'Bitcoin', 'Bitcoin', 'http://bitcoin.org'
)
; 

insert into Protocols values (
	'Mastercoin', 'Bitcoin', 'http://mastercoin.org'
)
;
